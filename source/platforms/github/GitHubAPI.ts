import { Octokit as GitHubNodeAPI } from "@octokit/rest"
import { debug } from "../../debug"
import * as node_fetch from "node-fetch"
import parse from "parse-link-header"
import pLimit from "p-limit"

import { GitHubPRDSL, GitHubIssueComment, GitHubUser } from "../../dsl/GitHubDSL"

import { dangerIDToString } from "../../runner/templates/githubIssueTemplate"
import { api as fetch } from "../../api/fetch"
import { RepoMetaData } from "../../dsl/RepoMetaData"
import { CheckOptions } from "./comms/checks/resultsToCheck"
import memoize from "lodash.memoize"

// The Handle the API specific parts of the github

export type APIToken = string

const limit = pLimit(25)

// Structure of files returned by the 'List pull request files' API
export interface GitHubFile {
  filename: string
  patch: string
  status: string
}

// Note that there are parts of this class which don't seem to be
// used by Danger, they are exposed for Peril support.

/** This represent the GitHub API */

export class GitHubAPI {
  fetch: typeof fetch
  additionalHeaders: any
  private readonly d = debug("GitHubAPI")

  private pr: GitHubPRDSL | undefined

  constructor(public readonly repoMetadata: RepoMetaData, public readonly token?: APIToken) {
    // This allows Peril to DI in a new Fetch function
    // which can handle unique API edge-cases around integrations
    this.fetch = fetch
    this.additionalHeaders = {}
  }

  /**
   * Bit weird, yes, but we want something that can be exposed to an end-user.
   * I wouldn't have a problem with moving this to use this API under the hood
   * but for now that's just a refactor someone can try.
   */
  getExternalAPI = (accessTokenForApp?: string): GitHubNodeAPI => {
    // A token should have been set by this point
    const token = accessTokenForApp || this.token!

    const host = process.env["DANGER_GITHUB_API_BASE_URL"] || "https://api.github.com"
    const options: ConstructorParameters<typeof GitHubNodeAPI>[0] & { debug: boolean } = {
      debug: !!process.env.LOG_FETCH_REQUESTS,
      baseUrl: host,
      auth: `token ${token}`,
    }

    if (this.additionalHeaders) {
      options.headers = this.additionalHeaders
    }

    return new GitHubNodeAPI(options)
  }

  /**
   * Grabs the contents of an individual file on GitHub
   *
   * @param {string} path path to the file
   * @param {string} [ref] an optional sha
   * @returns {Promise<string>} text contents
   *
   */
  fileContents = async (path: string, repoSlug?: string, ref?: string): Promise<string> => {
    // Use the current state of PR if no repo/ref is passed
    if (!repoSlug || !ref) {
      const prJSON = await this.getPullRequestInfo()
      repoSlug = prJSON.head.repo.full_name
      ref = prJSON.head.ref
    }

    const data = await this.getFileContents(path, repoSlug, ref)
    const buffer = Buffer.from(data.content, "base64")
    return buffer.toString()
  }

  // The above is the API for Platform

  getDangerCommentIDs = async (dangerID: string): Promise<string[]> => {
    const allComments = await this.getPullRequestComments()
    const dangerIDMessage = dangerIDToString(dangerID)
    this.d(`Looking at ${allComments.length} comments for ${dangerIDMessage}`)
    return allComments
      .filter((comment) => comment.body.includes(dangerIDMessage)) // does it contain the right danger ID?
      .filter((comment) => comment.body.includes("Generated by")) // Does it look like a danger message?
      .map((comment) => comment.id) // only return IDs
  }

  updateCommentWithID = async (id: string, comment: string): Promise<any> => {
    const repo = this.repoMetadata.repoSlug
    const res = await this.patch(
      `repos/${repo}/issues/comments/${id}`,
      {},
      {
        body: comment,
      }
    )

    return res.json()
  }

  deleteCommentWithID = async (id: string): Promise<boolean> => {
    const repo = this.repoMetadata.repoSlug
    const res = await this.api(`repos/${repo}/issues/comments/${id}`, {}, null, "DELETE")

    //https://developer.github.com/v3/issues/comments/#response-5
    return Promise.resolve(res.status === 204)
  }

  deleteInlineCommentWithID = async (id: string): Promise<boolean> => {
    const repo = this.repoMetadata.repoSlug
    const res = await this.api(`repos/${repo}/pulls/comments/${id}`, {}, null, "DELETE", false)

    //https://developer.github.com/v3/pulls/comments/#response-5
    return Promise.resolve(res.status === 204)
  }

  getUserID = async (): Promise<number | undefined> => {
    const perilID = process.env["PERIL_BOT_USER_ID"]
    if (perilID) {
      return parseInt(perilID)
    }

    const info = await this.getUserInfo()
    if (info.id) {
      return info.id
    }

    const useGitHubActionsID = process.env["GITHUB_WORKFLOW"]
    if (useGitHubActionsID) {
      // Allow to customise the GitHub actions app ID for Github Enterprise
      const gheActionsID = process.env["DANGER_GHE_ACTIONS_BOT_USER_ID"]
      if (gheActionsID) {
        return parseInt(gheActionsID)
      }
      // This is the user.id of the github-actions app (https://github.com/apps/github-actions)
      // that is used to comment when using danger in a GitHub Action
      // with GITHUB_TOKEN (https://help.github.com/en/actions/configuring-and-managing-workflows/authenticating-with-the-github_token)
      return 41898282
    }

    this.d("Danger user ID is undefined.")
    return undefined
  }

  postPRComment = async (comment: string): Promise<any> => {
    const repo = this.repoMetadata.repoSlug
    const prID = this.repoMetadata.pullRequestID
    const res = await this.post(
      `repos/${repo}/issues/${prID}/comments`,
      {},
      {
        body: comment,
      }
    )

    return res.json()
  }

  postInlinePRComment = async (comment: string, commitId: string, path: string, position: number) => {
    const repo = this.repoMetadata.repoSlug
    const prID = this.repoMetadata.pullRequestID
    const res = await this.post(
      `repos/${repo}/pulls/${prID}/comments`,
      {},
      {
        body: comment,
        commit_id: commitId,
        path: path,
        position: position,
      },
      false
    )
    if (res.ok) {
      return res.json()
    } else {
      throw await res.json()
    }
  }

  postInlinePRReview = async (commitId: string, comments: { comment: string; path: string; position: number }[]) => {
    const repo = this.repoMetadata.repoSlug
    const prID = this.repoMetadata.pullRequestID
    const res = await this.post(
      `repos/${repo}/pulls/${prID}/reviews`,
      {},
      {
        body: "",
        event: "COMMENT",
        commit_id: commitId,
        comments: comments.map(({ comment, path, position }) => ({
          body: comment,
          path,
          position,
        })),
      },
      false
    )
    if (res.ok) {
      return res.json()
    } else {
      throw await res.json()
    }
  }

  updateInlinePRComment = async (comment: string, commentId: string) => {
    const repo = this.repoMetadata.repoSlug
    const res = await this.patch(
      `repos/${repo}/pulls/comments/${commentId}`,
      {},
      {
        body: comment,
      },
      false
    )
    if (res.ok) {
      return res.json()
    } else {
      throw await res.json()
    }
  }

  getPullRequestInfo = async (): Promise<GitHubPRDSL> => {
    if (this.pr) {
      return this.pr
    }
    const repo = this.repoMetadata.repoSlug
    const prID = this.repoMetadata.pullRequestID
    const res = await this.get(`repos/${repo}/pulls/${prID}`)
    const prDSL = (await res.json()) as GitHubPRDSL
    this.pr = prDSL

    if (res.ok) {
      return prDSL
    } else {
      throw `Could not get PR Metadata for repos/${repo}/pulls/${prID}`
    }
  }

  getPullRequestCommits = async (): Promise<any[]> => {
    const repo = this.repoMetadata.repoSlug
    const prID = this.repoMetadata.pullRequestID
    return await this.getAllOfResource(`repos/${repo}/pulls/${prID}/commits`)
  }

  /**
   * Get list of commits in pull requests. This'll try to iterate all available pages
   * Until it reaches hard limit of api itself (250 commits).
   * https://developer.github.com/v3/pulls/#list-commits-on-a-pull-request
   *
   */
  getAllOfResource = async (path: string): Promise<any> => {
    const ret: Array<any> = []

    /**
     * Read response header and locate next page for pagination via link header.
     * If not found, will return -1.
     *
     * @param response Github API response sent via node-fetch
     */
    const getNextPageFromLinkHeader = (response: node_fetch.Response): number => {
      const linkHeader = response.headers.get("link")
      if (!linkHeader) {
        this.d(`getNextPageFromLinkHeader:: Given response does not contain link header for pagination`)
        return -1
      }

      const parsedHeader = parse(linkHeader)
      this.d(`getNextPageFromLinkHeader:: Link header found`, parsedHeader)
      if (!!parsedHeader.next && !!parsedHeader.next.page) {
        return parsedHeader.next.page
      }
      return -1
    }

    //iterates commit request pages until next page's not available, or response failed for some reason.
    let page = 0
    while (page >= 0) {
      const requestUrl = `${path}${page > 0 ? `?page=${page}` : ""}`
      this.d(`getPullRequestCommits:: Sending pull request commit request for ${page === 0 ? "first" : `${page}`} page`)
      this.d(`getPullRequestCommits:: Request url generated "${requestUrl}"`)

      const response = await this.get(requestUrl)
      if (response.ok) {
        ret.push(...(await response.json()))
        page = getNextPageFromLinkHeader(response)
      } else {
        this.d(
          `getPullRequestCommits:: Failed to get response while traverse page ${page} with ${response.status}, bailing rest of pages if exists`
        )
        page = -1
      }
    }

    return ret
  }

  getUserInfo = async (): Promise<GitHubUser> => {
    const response = await this.get("user")
    return response.json()
  }

  /**
   * Fetches all comments from a Pull Request on GitHub.
   *
   * This function retrieves all the comments associated with a given pull request.
   * It makes a request to the GitHub API endpoint that returns all comments for the
   * specified pull request.
   *
   * https://docs.github.com/en/rest/issues/comments?apiVersion=2022-11-28#list-issue-comments
   *
   * @returns {Promise<GitHubIssueComment[]>} A promise that resolves to an array of GitHub issue comments.
   *
   */
  getPullRequestComments = memoize(async (): Promise<GitHubIssueComment[]> => {
    const repo = this.repoMetadata.repoSlug
    const prID = this.repoMetadata.pullRequestID
    return await this.getAllOfResource(`repos/${repo}/issues/${prID}/comments`)
  })

  getPullRequestInlineComments = async (
    dangerID: string
  ): Promise<(GitHubIssueComment & { ownedByDanger: boolean })[]> => {
    const repo = this.repoMetadata.repoSlug
    const prID = this.repoMetadata.pullRequestID
    const dangerIDMessage = dangerIDToString(dangerID)
    return await this.getAllOfResource(`repos/${repo}/pulls/${prID}/comments`).then((v: GitHubIssueComment[]) => {
      return v
        .filter((i) => !!i)
        .map((i) => {
          // Can't use && i.body.includes("Generated by") because it's not there on an inline comment
          return { ...i, ownedByDanger: i.body.includes(dangerIDMessage) }
        })
        .filter((i) => i.ownedByDanger)
    })
  }

  getPullRequestFiles = async (page: number = 1): Promise<GitHubFile[]> => {
    const repo = this.repoMetadata.repoSlug
    const prID = this.repoMetadata.pullRequestID
    const perPage = 100
    const url = `repos/${repo}/pulls/${prID}/files?page=${page}&per_page=${perPage}`

    try {
      const response = await this.get(url, {
        Accept: "application/vnd.github.v3.diff",
      })
      const data = await response.json()

      if (!response.ok) {
        throw new Error(`GitHub 'List pull request files' API returned an error: ${data.message}`)
      }

      // Check for pagination using the Link header
      const linkHeader = response.headers.get("Link")
      const hasNextPage = linkHeader && linkHeader.includes('rel="next"')

      // If there's a next page, recursively fetch it and concatenate the results
      if (hasNextPage) {
        const nextPageNumber = page + 1
        const nextPageFiles = await this.getPullRequestFiles(nextPageNumber)
        return [...data, ...nextPageFiles]
      }

      return data as GitHubFile[]
    } catch (error) {
      console.error("Failed to fetch GitHub pull request files:", error)
      throw error
    }
  }

  getPullRequestDiff = async (): Promise<string> => {
    // This is a hack to get the file patch into a format that parse-diff accepts
    // as the GitHub API for listing pull request files is missing file names in the patch.
    function prefixedPatch(file: GitHubFile): string {
      let fileMode = ""
      if (file.status == "added") {
        fileMode = "new file mode"
      } else if (file.status == "removed") {
        fileMode = "deleted file mode"
      } else if (file.status == "modified") {
        fileMode = "modified file mode"
      }
      return `
diff --git a/${file.filename} b/${file.filename}
${fileMode} 0
--- a/${file.filename}
+++ b/${file.filename}
${file.patch}
`
    }

    try {
      const files = await this.getPullRequestFiles()
      const diff = files.map(prefixedPatch).join("\n")
      return diff
    } catch (error) {
      console.error("Failed to fetch pull request diff:", error)
      return ""
    }
  }

  getFileContents = async (path: string, repoSlug: string, ref: string): Promise<any> => {
    const res = await this.get(`repos/${repoSlug}/contents/${path}?ref=${ref}`)
    return res.ok ? res.json() : { content: "" }
  }

  getPullRequests = async (): Promise<any> => {
    const repo = this.repoMetadata.repoSlug
    const res = await this.get(`repos/${repo}/pulls`)

    return res.ok ? res.json() : []
  }

  getReviewerRequests = async (): Promise<any> => {
    const repo = this.repoMetadata.repoSlug
    const prID = this.repoMetadata.pullRequestID
    const res = await this.get(`repos/${repo}/pulls/${prID}/requested_reviewers`, {
      Accept: "application/vnd.github.v3+json",
    })

    return res.ok ? res.json() : []
  }

  getReviews = async (): Promise<any> => {
    const repo = this.repoMetadata.repoSlug
    const prID = this.repoMetadata.pullRequestID
    const res = await this.get(`repos/${repo}/pulls/${prID}/reviews`, {
      Accept: "application/vnd.github.v3+json",
    })

    return res.ok ? res.json() : []
  }

  getIssue = async (): Promise<any> => {
    const repo = this.repoMetadata.repoSlug
    const prID = this.repoMetadata.pullRequestID
    const res = await this.get(`repos/${repo}/issues/${prID}`)

    return res.ok ? res.json() : { labels: [] }
  }

  updateStatus = async (
    passed: boolean | "pending",
    message: string,
    url?: string,
    dangerID?: string,
    ciCommitHash?: string
  ): Promise<any> => {
    const repo = this.repoMetadata.repoSlug

    const prJSON = await this.getPullRequestInfo()
    const ref = ciCommitHash || prJSON.head.sha

    let state = passed ? "success" : "failure"
    if (passed === "pending") {
      state = "pending"
    }

    // This is the bold bit of the status message, it kinda feels like
    // the name of the service.
    let context = dangerID || "Danger"

    // Suppress errors, because in OSS
    // this failure could be due to access rights.
    //
    // So only error when it's a real message.
    const statusURL = `repos/${repo}/statuses/${ref}`
    try {
      const res = await this.post(
        statusURL,
        {},
        {
          state: state,
          context: context,
          target_url: url || "http://danger.systems/js",
          description: message,
        },
        true
      )
      if (!res.ok) {
        this.d(`Got a non-OK (${res.status} ${res.statusText}) response from ${statusURL}:`)
        this.d(JSON.stringify(res, null, "  "))
      }
      return res.ok
    } catch (error) {
      this.d(`Posting a status to: ${statusURL} failed, this is the response:`)
      this.d((error && (error as Error).message) || error)
    }
  }

  postCheckRun = async (check: CheckOptions, token: string) => {
    const repo = this.repoMetadata.repoSlug
    const res = await this.post(
      `repos/${repo}/check-runs`,
      {
        Accept: "application/vnd.github.antiope-preview+json,application/vnd.github.machine-man-preview+json",
        Authorization: `token ${token}`,
      },
      check
    )
    if (res.ok) {
      return res.json()
    } else {
      throw await res.json()
    }
  }

  // API Helpers

  private api = (path: string, headers: any = {}, body: any = {}, method: string, suppressErrors?: boolean) => {
    if (this.token && !headers["Authorization"]) {
      headers["Authorization"] = `token ${this.token}`
    }

    const containsBase = path.startsWith("http")
    const baseUrl = process.env["DANGER_GITHUB_API_BASE_URL"] || "https://api.github.com"
    const url = containsBase ? path : `${baseUrl}/${path}`

    let customAccept = {}
    if (headers.Accept && this.additionalHeaders.Accept) {
      // We need to merge the accepts which are comma separated according to the HTML spec
      // e.g. https://gist.github.com/LTe/5270348

      // But make sure it doesn't already include it
      if (headers.Accept.includes(this.additionalHeaders.Accept)) {
        // If it's already a subset, ignore
        customAccept = { Accept: headers.Accept }
      } else {
        customAccept = { Accept: `${this.additionalHeaders.Accept}, ${headers.Accept}` }
      }
    }
    const finalHeaders = {
      "Content-Type": "application/json",
      ...headers,
      ...this.additionalHeaders,
      ...customAccept,
    }

    this.d("Sending: ", url, finalHeaders)
    return limit(() =>
      this.fetch(
        url,
        {
          method,
          body,
          headers: finalHeaders,
        },
        suppressErrors
      )
    )
  }

  get = (path: string, headers: any = {}): Promise<node_fetch.Response> => this.api(path, headers, null, "GET")

  post = (path: string, headers: any = {}, body: any = {}, suppressErrors?: boolean): Promise<node_fetch.Response> =>
    this.api(path, headers, JSON.stringify(body), "POST", suppressErrors)

  patch = (path: string, headers: any = {}, body: any = {}, suppressErrors?: boolean): Promise<node_fetch.Response> =>
    this.api(path, headers, JSON.stringify(body), "PATCH", suppressErrors)
}
